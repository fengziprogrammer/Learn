1、所有hash结构的集合都会依赖于元素的hashCode值
理想情况下，希望不同的对象得到不同的hashCode值，
现实中，可能出现不同的对象得到相同的hashCode值。

结论/常规协定：
    （1）如果两个对象的hashCode值不同，那么这个两个对象一定不相等，所以就不用看equals方法。
    hashCode值的比较要简单很多，因为是一个int值的比较，
    而equals比较相对复杂，可能比较很多属性值。
    （2）如果两个对象调用equals相同，那么这个两个对象hashCode一定要相同，否则就有问题。
    重写equals方法时，一定要重写hashCode方法，而且选择的属性也要一样
    （3）如果两个对象的hashCode值相同，那么这个两个对象可能相同，也可能不同，
    所以还需要再次调用equals方法做比较。

2、hashCode在哈希表中怎么用？
    因为hashCode值是int类型，可以用它直接作为数组的[下标]。

如果数组可以足够大，那么就可以直接用 hashCode值当下标，这是最快的。
但是数组首先不可能足够大，而且元素可能没有那么多，创建足够大的数组有点浪费。
那么实际中会用  hashCode值 通过某种公式 计算出一个合理的[下标]。

（1）方案一：
  hashCode值 % 数组的长度 = 下标
  A：重复，是肯定的
  B：下标是否会越界，不会，[0,数组的长度)，[0，数组的长度-1]

（2）方案二：&比%的效率高
  hashCode值 & （数组的长度-1） = 下标
  A：重复，是肯定的
  B：下标是否会越界，不会，[0,数组的长度)，[0，数组的长度-1]

 假设：数组的长度为16，数组的长度-1=15
 hashCode值   ???? ????  二进制
 数组的长度-1  0000 1111  二进制
 &-----------------------------
              0000 0000         0
              0000 0001         1
              0000 0010         2
              0000 0011
              0000 0100
              ....
              0000 1111         15

 数组的长度选择？讲究，数组的长度最好选择2的n次方。
 假设：数组的长度为10，数组的长度-1=9
  hashCode值   ???? ????  二进制
  数组的长度-1  0000 1001  二进制
  &-----------------------------
               0000 0000         0
               0000 0001         1
               0000 1000         8
               0000 1001         9
               范围也是[0,9]但是只有4种可能，冲突的概率更高。

 （3）方案三：
 先对hashCode值做处理得到一个hash值，再用hash值 & （数组的长度-1）

  假设：数组的长度为16，数组的长度-1=15
  hashCode值   ???? ????  二进制
  数组的长度-1  0000 1111  二进制
  无论hashCode值的高位部分是什么值，都完全没有意义了，区分下标只能靠低几位的二进制值。
  这种情况会导致hash冲突概率增加。

  hashCode值处理  ???? xxxx 二进制
    数组的长度-1  0000  1111  二进制

  处理过的xxxx在JDK1.8版本中，会包含原来hashCode值高位的信息。
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
    hashCode是int类型，4个字节，总共32位。
    h >>> 16，取高16位二进制值。
    (h = key.hashCode()) ^ (h >>> 16)相当于
    用hashCode值的原二进制
    与
    高16位全是0低16位是原来二进制的高16值
    进行与运算

    0111 1100 0011 1111 1100 0111 1010 0101(1)
    0000 0000 0000 0000 0111 1100 0011 1111(2)
    ^--------------------------------------
    0111 1100 0011 1111 1011 1011 1001 1010(3) 和(1)不同

结论：方案三可以保证两点
（1）hash冲突概率降低，但是无法避免
（2）数组的每一种下标都有可能
由这两点，尽量让(key,value)均匀存放到HashMap中，但是不能保证绝对均匀。
而且不能保证按顺序存储，中间可能有空位。

3、如何解决hash冲突问题？
（1）什么是hash冲突
A：两个对象的hashCode值相同
B：两个对象的hashCode不同，但是经过计算 index相同
（2）如何解决？
hash冲突意味着数组的某个位置需要存储多个元素。
需要重新设计这个元素的类型，不能直接存储元素的值，
而是要把元素用“结点”封装起来，这个结点可以是链表的结点，也可以是“树”的结点。
JDK1.7：使用纯链表结点封装
JDK1.8：既有链表结点又有树结点（而且还是红黑树结点）
    树的好处，就是提高了查询效率。
（3）JDK1.8为什么不干脆全部使用树结点呢，还要保留链表结点。
因为红黑树比较复杂，而且每次添加和删除的时候，都要调整，会使得效率降低。
当链表的结点个数没有那么多的时候，使用链表反而更快。


4、什么时候需要从链表变成树？
（1）数组的长度>=64
static final int MIN_TREEIFY_CAPACITY = 64;
（2）链表结点的个数>8
static final int TREEIFY_THRESHOLD = 8;

5、如果数组的长度不够64，链表的结点个数达到8个怎么办？
会先扩容数组，再处理。

为什么是扩容解决呢？
扩容有什么影响？ 数组的长度变大了（扩容为2倍），就要重新计算下标。

假设数组的长度是16，数组的长度-1=15
hashCode值处理  ???? xxxx 二进制
数组的长度-1    0000 1111  二进制

假设数组的长度是32，数组的长度-1=31
hashCode值处理  ???y xxxx 二进制
数组的长度-1    0001  1111  二进制

如果y位置是0，扩容后没有影响。
如果y位置是1，扩容后就有影响。


数组扩容了，计算的下标会可能变，变了就会导致(key,value)换一个位置存储，
原来链表有8个节点，可能换位置之后可能没有8个了。

6、问题：哈希表中的链表变为树之后，还会不会变回链表？
会

7、什么时候会从树变回链表？
（1）一直删除时，如果树的结点个数少于UNTREEIFY_THRESHOLD（6）个时，会考虑变会链表（称为反树化）。
同时还要考虑：删除过程中发现
            当树的根结点的左或右结点为NULL时，就会考虑反树化。
            或者当树的根结点的左左结点为NULL时，也会考虑反树化。

（2）添加操作引起了扩容，扩容过程中，因为移动位置导致树的结点个数少于6个，会考虑把树变为链表。


8、问题：除了树化的table.length没有达到64，但是结点的数量达到8了，导致数组扩容之外，
有没有其他的条件会让数组扩容？
会

9、什么时候扩容？
（1）当map的元素个数size > threshold时，就会扩容
扩容为原来的2倍。
第一次：threshold（阈值）= DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY
后面：threshold（阈值）= loadFactor（默认值是0.75）  * table.length（最开始是16） = 原来的threshold * 2;
假设：table.length是64，threshold = 64*0.75=48


















10、跟踪源码发现，HashMap的Entry实现类，不管是JDK1.7的Entry类，还是JDK1.8类的Node类
都会存储hash值。为什么要存储？
因为我们每一次查询，添加、删除等操作。
以查询为例：
    (key,value)在不在map中。
    用要查询的对象的key的hash值与原有的(key,value)的key的hash值做比较，
    hash值相同的情况下，才会比较equals方法。
    如果hash不存起来，每一次比较的时候都要重新计算，这就会影响效率。