<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>原型</title>
    <script>

        /*
        *   每个函数对象中都有一个属性叫做prototype，
        *       该属性指向的是一个对象，这个对象原型对象
        *       如果函数作为普通函数调用，则原型对象（prototype）没有任何作用
        *       如果函数作为构造函数调用，那么通过该构造函数所创建的对象中
        *           都会有一个隐含的属性（__proto__）指向函数的原型对象（prototype）
        *
        *       也就是说，该类的所有实例中都会有一个隐含属性指向构造函数的prototype，
        *           原型对象，就相当于一个公共的区域可以被所有的该类实例访问
        *           可以将一些实例共有的属性或方法存储在原型对象中，
        *               这样只需要设置一次即可让所有的对象都访问到该属性
        *
        *       当我们访问一个对象中的属性时，JS会先在对象本身中寻找，
        *           如果找到了则直接使用，
        *           如果没有找到则去对象的原型(__proto__)中寻找
        *           找到了则使用，如果没有找到则去原型的原型中寻找
        *           如果找到了则使用，如果没有找到以此类推..
        *           直到找到Object的原型，如果依然没有，则返回undefined，不会报错
        *           这个搜索的过程称为原型链
        *
        *           Object的prototype是所有对象的原型，它的原型为null
        *
        *
        *       结论：
        *           定义一个类时，如果属性和方法是对象独有的，就直接在构造函数中设置
        *               function 类名(){
        *                   this.xxx = yyy;
        *               }
        *
        *           如果属性和方法是公共的，每一个对象的值都是相同，可以通过原型来添加
        *               类.prototype.属性名 = 值;
        *
        *
        * */

        function MyClass() {

        }

        // 向原型中添加一个属性
        MyClass.prototype.name = '原型中的name属性';

        let mc = new MyClass();
        let mc2 = new MyClass();
        let mc3 = new MyClass();

        mc.name = '孙悟空';

        // 访问mc中的隐含属性
        // console.log(mc2.__proto__ === MyClass.prototype);
        console.log(mc.name);
        console.log(mc2.name);
        console.log(mc3.name);

    </script>
</head>
<body>

</body>
</html>