<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
  //    面向对象语言三大特征： 封装 继承 多态
//    在js（es5）当中 我们可以将构造函数 理解为类
//    在es6当中 出现了一个新的关键字  class类
  // 不过他也不是真正的类  底层依旧是通过封装构造函数来实现的  其本质就是一个语法糖
//    咱们研究继承  核心的问题 就是为了让子类 能够继承父类已有的 属性和方法
    function Dog(name,color,age) {
        this.name = name;
        this.color = color;
        this.age = age;
    }
      Dog.prototype.run = function () {
          console.log('我可以跑')
      }
      Dog.prototype.eat = function () {
          console.log('我很能吃')
      }
    function Corky(name,color,age) {
//        this.name = name;
//        this.color = color;
//        this.age = age;
//      当前作用域内 this是 Corky的实例化对象
//      这种继承方式 叫做借助构造函数继承    专门让子类继承父类的属性
        Dog.call(this,name,color,age);
    }
//  原型链式继承     让子类的原型 等于 父类的一个实例
  Corky.prototype = new Dog();
//  我们需要手动的将Corky原型上的构造器属性 重新指向Corky
  Corky.prototype.constructor = Corky;
//  剩下的第三种 我们叫做混合继承  就是将构造函数继承和原型继承 一起使用
    var d1 = new Dog('wangcai','black',3);
    var c1 = new Corky('dapi','black',3);
    d1.run();
//  用c1调用一个方法 自身没有的是   会沿着__proto__  去找构造函数的prototype
//  但是现在Corky的prototype指向 Dom的实例
//  Don的实例 也没有这个方法  但是可以顺着实例化对象的 __proto__  找到Dog的prototype
    c1.run();
    console.log(d1)
    console.log(c1)

</script>
</body>
</html>